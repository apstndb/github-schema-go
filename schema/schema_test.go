package schema

import (
	"strings"
	"testing"
)

// Test data - minimal schema for testing
var testSchemaData = []byte(`{
  "data": {
    "__schema": {
      "types": [
        {
          "name": "PullRequest",
          "kind": "OBJECT",
          "description": "A repository pull request.",
          "fields": [
            {
              "name": "id",
              "description": "The ID of the pull request",
              "type": {
                "name": null,
                "kind": "NON_NULL",
                "ofType": {
                  "name": "ID",
                  "kind": "SCALAR"
                }
              },
              "args": []
            },
            {
              "name": "title",
              "description": "The title of the pull request",
              "type": {
                "name": "String",
                "kind": "SCALAR"
              },
              "args": []
            }
          ]
        },
        {
          "name": "Issue",
          "kind": "OBJECT",
          "description": "An Issue is a place to discuss ideas.",
          "fields": []
        },
        {
          "name": "CreateIssueInput",
          "kind": "INPUT_OBJECT",
          "description": "Autogenerated input type of CreateIssue",
          "inputFields": [
            {
              "name": "title",
              "description": "The title for the issue",
              "type": {
                "name": null,
                "kind": "NON_NULL",
                "ofType": {
                  "name": "String",
                  "kind": "SCALAR"
                }
              }
            }
          ]
        },
        {
          "name": "Mutation",
          "kind": "OBJECT",
          "fields": [
            {
              "name": "createIssue",
              "description": "Creates a new issue.",
              "args": [
                {
                  "name": "input",
                  "description": "Parameters for CreateIssue",
                  "type": {
                    "name": null,
                    "kind": "NON_NULL",
                    "ofType": {
                      "name": "CreateIssueInput",
                      "kind": "INPUT_OBJECT"
                    }
                  }
                }
              ]
            }
          ]
        }
      ]
    }
  }
}`)

func TestNewWithData(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}
	if s == nil {
		t.Fatal("Schema should not be nil")
	}
}

func TestType(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	tests := []struct {
		name     string
		typeName string
		wantErr  bool
		validate func(t *testing.T, result map[string]interface{})
	}{
		{
			name:     "valid object type",
			typeName: "PullRequest",
			wantErr:  false,
			validate: func(t *testing.T, result map[string]interface{}) {
				typeInfo := result["type"].(map[string]interface{})
				if typeInfo["name"] != "PullRequest" {
					t.Errorf("Expected name PullRequest, got %v", typeInfo["name"])
				}
				if typeInfo["kind"] != "OBJECT" {
					t.Errorf("Expected kind OBJECT, got %v", typeInfo["kind"])
				}
				fields := typeInfo["fields"].([]interface{})
				if len(fields) != 2 {
					t.Errorf("Expected 2 fields, got %d", len(fields))
				}
			},
		},
		{
			name:     "valid input type",
			typeName: "CreateIssueInput",
			wantErr:  false,
			validate: func(t *testing.T, result map[string]interface{}) {
				typeInfo := result["type"].(map[string]interface{})
				if typeInfo["kind"] != "INPUT_OBJECT" {
					t.Errorf("Expected kind INPUT_OBJECT, got %v", typeInfo["kind"])
				}
				inputFields := typeInfo["inputFields"].([]interface{})
				if len(inputFields) != 1 {
					t.Errorf("Expected 1 input field, got %d", len(inputFields))
				}
			},
		},
		{
			name:     "non-existent type",
			typeName: "NonExistent",
			wantErr:  true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := s.Type(tt.typeName)
			if (err != nil) != tt.wantErr {
				t.Errorf("Type() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && tt.validate != nil {
				tt.validate(t, result)
			}
		})
	}
}

func TestSearch(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	tests := []struct {
		name     string
		pattern  string
		wantErr  bool
		validate func(t *testing.T, result map[string]interface{})
	}{
		{
			name:    "search for Issue",
			pattern: "Issue",
			wantErr: false,
			validate: func(t *testing.T, result map[string]interface{}) {
				// Handle both int and float64 types
				var count int
				switch v := result["count"].(type) {
				case float64:
					count = int(v)
				case int:
					count = v
				default:
					t.Fatalf("Unexpected count type: %T", v)
				}
				if count != 2 { // Issue and CreateIssueInput
					t.Errorf("Expected 2 results, got %d", count)
				}
				results := result["results"].([]interface{})
				found := false
				for _, r := range results {
					item := r.(map[string]interface{})
					if item["name"] == "Issue" {
						found = true
						break
					}
				}
				if !found {
					t.Error("Expected to find Issue type")
				}
			},
		},
		{
			name:    "case insensitive search",
			pattern: "pull",
			wantErr: false,
			validate: func(t *testing.T, result map[string]interface{}) {
				// Handle both int and float64 types
				var count int
				switch v := result["count"].(type) {
				case float64:
					count = int(v)
				case int:
					count = v
				default:
					t.Fatalf("Unexpected count type: %T", v)
				}
				if count != 1 {
					t.Errorf("Expected 1 result, got %d", count)
				}
			},
		},
		{
			name:    "no matches",
			pattern: "NoMatch",
			wantErr: false,
			validate: func(t *testing.T, result map[string]interface{}) {
				// Handle both int and float64 types
				var count int
				switch v := result["count"].(type) {
				case float64:
					count = int(v)
				case int:
					count = v
				default:
					t.Fatalf("Unexpected count type: %T", v)
				}
				if count != 0 {
					t.Errorf("Expected 0 results, got %d", count)
				}
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := s.Search(tt.pattern)
			if (err != nil) != tt.wantErr {
				t.Errorf("Search() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && tt.validate != nil {
				tt.validate(t, result)
			}
		})
	}
}

func TestMutation(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	tests := []struct {
		name         string
		mutationName string
		wantErr      bool
		validate     func(t *testing.T, result map[string]interface{})
	}{
		{
			name:         "valid mutation",
			mutationName: "createIssue",
			wantErr:      false,
			validate: func(t *testing.T, result map[string]interface{}) {
				mutation := result["mutation"].(map[string]interface{})
				if mutation["name"] != "createIssue" {
					t.Errorf("Expected name createIssue, got %v", mutation["name"])
				}
				inputs := mutation["inputs"].([]interface{})
				if len(inputs) != 1 {
					t.Errorf("Expected 1 input, got %d", len(inputs))
				}
			},
		},
		{
			name:         "non-existent mutation",
			mutationName: "nonExistent",
			wantErr:      true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := s.Mutation(tt.mutationName)
			if (err != nil) != tt.wantErr {
				t.Errorf("Mutation() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && tt.validate != nil {
				tt.validate(t, result)
			}
		})
	}
}

func TestQuery(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	tests := []struct {
		name      string
		query     string
		variables map[string]interface{}
		wantErr   bool
		validate  func(t *testing.T, result interface{})
	}{
		{
			name:      "simple query",
			query:     `.data.__schema.types | length`,
			variables: nil,
			wantErr:   false,
			validate: func(t *testing.T, result interface{}) {
				// Handle both int and float64 types
				var count int
				switch v := result.(type) {
				case float64:
					count = int(v)
				case int:
					count = v
				default:
					t.Fatalf("Unexpected result type: %T", v)
				}
				if count != 4 {
					t.Errorf("Expected 4 types, got %d", count)
				}
			},
		},
		{
			name:      "query with variable",
			query:     `.data.__schema.types[] | select(.name == $name) | .kind`,
			variables: map[string]interface{}{"$name": "PullRequest"},
			wantErr:   false,
			validate: func(t *testing.T, result interface{}) {
				kind := result.(string)
				if kind != "OBJECT" {
					t.Errorf("Expected kind OBJECT, got %s", kind)
				}
			},
		},
		{
			name:      "invalid query",
			query:     `invalid jq syntax {{`,
			variables: nil,
			wantErr:   true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result, err := s.Query(tt.query, tt.variables)
			if (err != nil) != tt.wantErr {
				t.Errorf("Query() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && tt.validate != nil {
				tt.validate(t, result)
			}
		})
	}
}

func TestVariableHandling(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	// Test that variables are properly sorted and passed
	query := `.data.__schema.types[] | select(.name == $b or .name == $a) | .name`
	variables := map[string]interface{}{
		"$b": "Issue",
		"$a": "PullRequest",
	}

	result, err := s.Query(query, variables)
	if err != nil {
		t.Fatalf("Query with multiple variables failed: %v", err)
	}

	// Result should be an array of names
	results, ok := result.([]interface{})
	if !ok {
		t.Fatalf("Expected array result, got %T", result)
	}

	if len(results) != 2 {
		t.Errorf("Expected 2 results, got %d", len(results))
	}

	// Check both names are present
	names := make(map[string]bool)
	for _, r := range results {
		names[r.(string)] = true
	}

	if !names["PullRequest"] || !names["Issue"] {
		t.Errorf("Expected both PullRequest and Issue, got %v", names)
	}
}

func TestFormatTypeRef(t *testing.T) {
	// Test the formatType function in queries through actual usage
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	result, err := s.Type("PullRequest")
	if err != nil {
		t.Fatalf("Failed to get PullRequest type: %v", err)
	}

	typeInfo := result["type"].(map[string]interface{})
	fields := typeInfo["fields"].([]interface{})

	// Check that NON_NULL types are formatted correctly
	for _, f := range fields {
		field := f.(map[string]interface{})
		if field["name"] == "id" {
			typeStr := field["type"].(string)
			if typeStr != "ID!" {
				t.Errorf("Expected ID! for id field type, got %s", typeStr)
			}
		}
	}
}

func TestNewWithFile_NotExist(t *testing.T) {
	_, err := NewWithFile("/non/existent/file.json")
	if err == nil {
		t.Error("Expected error for non-existent file")
	}
	if !strings.Contains(err.Error(), "failed to read schema file") {
		t.Errorf("Expected 'failed to read schema file' error, got: %v", err)
	}
}

func TestNewWithData_InvalidJSON(t *testing.T) {
	_, err := NewWithData([]byte("invalid json"))
	if err == nil {
		t.Error("Expected error for invalid JSON")
	}
	if !strings.Contains(err.Error(), "failed to parse schema") {
		t.Errorf("Expected 'failed to parse schema' error, got: %v", err)
	}
}

func TestEmptyResults(t *testing.T) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		t.Fatalf("Failed to create schema: %v", err)
	}

	// Query that returns no results
	result, err := s.Query(`.data.__schema.types[] | select(.name == "NoSuchType")`, nil)
	if err != nil {
		t.Fatalf("Query failed: %v", err)
	}

	if result != nil {
		t.Errorf("Expected nil result for no matches, got %v", result)
	}
}

// Benchmark for performance testing
func BenchmarkType(b *testing.B) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		b.Fatalf("Failed to create schema: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := s.Type("PullRequest")
		if err != nil {
			b.Fatal(err)
		}
	}
}

func BenchmarkSearch(b *testing.B) {
	s, err := NewWithData(testSchemaData)
	if err != nil {
		b.Fatalf("Failed to create schema: %v", err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, err := s.Search("Issue")
		if err != nil {
			b.Fatal(err)
		}
	}
}